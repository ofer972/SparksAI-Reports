import { NextRequest, NextResponse } from 'next/server';

export async function middleware(request: NextRequest) {
  return NextResponse.next();
  
  /*
  // Only handle /api routes
  if (!request.nextUrl.pathname.startsWith('/api/')) {
    return NextResponse.next();
  }

  // Log the incoming request method for debugging (especially on Railway)
  console.log(`[Middleware] ${request.method} ${request.nextUrl.pathname}`);

  // Get backend URL from environment variables
  const backendUrl = process.env.INTERNAL_BACKEND_URL || 
                     process.env.NEXT_PUBLIC_BACKEND_URL || 
                     'http://localhost:8000';

  // Ensure destination is valid
  if (!/^https?:\/\//.test(backendUrl)) {
    console.error(`Invalid backend URL: "${backendUrl}"`);
    return NextResponse.json(
      { error: 'Invalid backend configuration' },
      { status: 500 }
    );
  }

  // Remove trailing slash if present
  const cleanBackendUrl = backendUrl.replace(/\/$/, '');

  // Get the path after /api
  const apiPath = request.nextUrl.pathname.replace(/^\/api/, '');
  
  // Construct the backend URL with query string
  const backendApiUrl = `${cleanBackendUrl}/api${apiPath}${request.nextUrl.search}`;

  // Create headers for the backend request
  const headers = new Headers();
  
  // Copy all request headers except host and connection
  request.headers.forEach((value, key) => {
    const lowerKey = key.toLowerCase();
    if (lowerKey !== 'host' && lowerKey !== 'connection') {
      headers.set(key, value);
    }
  });

  // Prepare fetch options with explicit method
  const fetchOptions: RequestInit = {
    method: request.method, // Explicitly preserve the HTTP method
    headers: headers,
    // Add cache control to prevent caching of non-GET requests
    cache: request.method === 'GET' ? 'default' : 'no-store',
  };

  // Handle request body for methods that support it
  const methodsWithBody = ['POST', 'PUT', 'PATCH', 'DELETE'];
  if (methodsWithBody.includes(request.method)) {
    try {
      // Read the request body
      const body = await request.text();
      if (body) {
        fetchOptions.body = body;
      }
    } catch (error) {
      console.error('Error reading request body:', error);
      // Continue without body if there's an error
    }
  }

  try {
    // Log the proxied request for debugging
    console.log(`[Middleware] Proxying ${fetchOptions.method} to ${backendApiUrl}`);
    
    // Proxy the request to the backend, preserving the HTTP method
    const response = await fetch(backendApiUrl, fetchOptions);
    
    // Get response body
    const responseBody = await response.text();
    
    // Create response with same status and headers
    const nextResponse = new NextResponse(responseBody, {
      status: response.status,
      statusText: response.statusText,
    });

    // Copy response headers (preserve Content-Type especially)
    response.headers.forEach((value, key) => {
      const lowerKey = key.toLowerCase();
      // Skip headers that Next.js/Edge runtime manages
      if (
        lowerKey !== 'content-encoding' &&
        lowerKey !== 'transfer-encoding' &&
        lowerKey !== 'content-length' &&
        lowerKey !== 'connection'
      ) {
        nextResponse.headers.set(key, value);
      }
    });

    return nextResponse;
  } catch (error) {
    console.error('Error proxying request to backend:', error);
    return NextResponse.json(
      { error: 'Failed to connect to backend', details: String(error) },
      { status: 502 }
    );
  }
  */
}

export const config = {
  matcher: '/api/:path*',
};

